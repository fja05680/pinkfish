<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>pinkfish.indicator API documentation</title>
<meta name="description" content="Custom indicators â€¦" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>pinkfish.indicator</code></h1>
</header>
<section id="section-intro">
<p>Custom indicators.</p>
<p>These indicators are meant to supplement the TA-Lib.
See:
<a href="https://ta-lib.org/function.html">https://ta-lib.org/function.html</a></p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;
Custom indicators.

These indicators are meant to supplement the TA-Lib.  See:
https://ta-lib.org/function.html
&#34;&#34;&#34;

import math
import numpy as np
import pandas as pd

import pinkfish.pfstatistics as pfstatistics


class IndicatorError(Exception):
    &#34;&#34;&#34;
    Base indicator exception.
    &#34;&#34;&#34;
    pass


########################################################################
# SMA

def SMA(ts, timeperiod=30, price=&#39;close&#39;):
    &#34;&#34;&#34;
    This indicator computes a simple moving average.

    Can be used in place of talib SMA.

    ts : pd.DateFrame or pd.Series
        A dataframe with &#39;open&#39;, &#39;high&#39;, &#39;low&#39;, &#39;close&#39;, &#39;volume&#39; or
        a series of price data.
    timeperiod: int, optional
        The timeperiod for the moving average (default is 30).
    price : str, optional {&#39;close&#39;, &#39;open&#39;, &#39;high&#39;, &#39;low&#39;}
        Input_array column to use for price (default is &#39;close&#39;).
        Not used if `ts` is a series.

    Returns
    -------
    pd.Series
        Series that contains the simple moving average.

    Examples
    --------
    &gt;&gt;&gt; ts[&#39;sma50&#39;] = pf.SMA(ts, timeperiod=50)
    &#34;&#34;&#34;
    s = ts[price] if isinstance(ts, pd.DataFrame) else ts
    return s.rolling(timeperiod).mean()


########################################################################
# EMA

def EMA(ts, timeperiod=30, price=&#39;close&#39;):
    &#34;&#34;&#34;
    This indicator computes an exponential moving average.

    Can be used in place of talib EMA.

    ts : pd.DateFrame or pd.Series
        A dataframe with &#39;open&#39;, &#39;high&#39;, &#39;low&#39;, &#39;close&#39;, &#39;volume&#39; or
        a series of price data.
    timeperiod: int, optional
        The timeperiod for the moving average (default is 30).
    price : str, optional {&#39;close&#39;, &#39;open&#39;, &#39;high&#39;, &#39;low&#39;}
        Input_array column to use for price (default is &#39;close&#39;).
        Not used if `ts` is a series.

    Returns
    -------
    pd.Series
        Series that contains the simple moving average.

    Examples
    --------
    &gt;&gt;&gt; ts[&#39;ema50&#39;] = pf.EMA(ts, timeperiod=50)
    &#34;&#34;&#34;
    s = ts[price] if isinstance(ts, pd.DataFrame) else ts
    return s.ewm(span=timeperiod, min_periods=timeperiod, adjust=False).mean()


########################################################################
# CROSSOVER

class TradeCrossOverError(IndicatorError):
    &#34;&#34;&#34;
    Invalid timeperiod specified.
    &#34;&#34;&#34;
    pass


class _CrossOver:
    &#34;&#34;&#34;
    This is a helper class to implement the CROSSOVER function.

     The class provides the apply callback for pd.DataFrame.apply()
     in CROSSOVER.  It also keeps track of _r, explained below.

    _r indicates regime direction and duration, i.e. 50 means a bull
       market that has persisted for 50 days, whereas -20 means a bear
       market that has persisted for 20 days.
    _r is incremented(decremented) each day a bull(bear) market persists
    _r remains unchanged when fast_ma within band of slow_ma
    _r indicates the number of trading days a trend has persisted
    _r is nan, then sma_slow is nan
    _r &gt; 0, then bull market, fast_ma &gt; slow_ma
    _r &lt; 0, then bear market, fast_ma &lt; slow_ma
    _r == 0, no trend established yet
    &#34;&#34;&#34;
    def __init__(self):
        &#34;&#34;&#34;
        Initialize instance variables.

        Attributes
        ----------
        _r : int
            Indicates regime direction and duration.
        &#34;&#34;&#34;
        self._r = 0

    def apply(self, row, band=0):
        &#34;&#34;&#34;
        Implements the regime change logic.

        Parameters
        ----------
        row : pd.Series
            A row of data from the dataframe.
        band : int {0-100}
            Percent band (default is 0, which is no band).

        Returns
        -------
        _r : int
            Indicates regime direction and duration.
        &#34;&#34;&#34;
        if pd.isnull(row[&#39;__sma_slow__&#39;]):
            self._r = np.nan
        elif row[&#39;__sma_fast__&#39;] &gt; row[&#39;__sma_slow__&#39;]*(1+band/100):
            self._r = self._r + 1 if self._r &gt; 0 else 1
        elif row[&#39;__sma_fast__&#39;] &lt; row[&#39;__sma_slow__&#39;]*(1-band/100):
            self._r = self._r -1 if self._r &lt; 0 else -1
        else:
            pass
        return self._r


def CROSSOVER(ts, timeperiod_fast=50, timeperiod_slow=200,
              func_fast=SMA, func_slow=SMA, band=0,
              price=&#39;close&#39;, prevday=False):
    &#34;&#34;&#34;
    This indicator is used to represent regime direction and duration.

    For example, an indicator value of 50 means a bull market that has
    persisted for 50 days, whereas -20 means a bear market that has
    persisted for 20 days.

    More generally, this is a crossover indicator for two moving
    averages.  The indicator is positive when the fast moving average
    is above the slow moving arverage, and negative when the fast
    moving average is below the slow moving average.

    Parameters
    ----------
    ts : pd.DateFrame
        A dataframe with &#39;open&#39;, &#39;high&#39;, &#39;low&#39;, &#39;close&#39;, &#39;volume&#39;.
    timeperiod_fast : int, optional
        The timeperiod for the fast moving average (default is 50).
    timeperiod_slow : int, optional
        The timeperiod for the slow moving average (default is 200).
    func_fast : Function, optional
        {pf.SMA, pf.EMA} (pinkfish functions) or
        {SMA, DEMA, EMA, KAMA, T3, TEMA, TRIMA, WMA} (ta-lib functions)
        The function for fast moving average (default is pf.SMA).
        MAMA not compatible.
    func_slow : Function, optional
         {pf.SMA, pf.EMA} (pinkfish functions) or
        {SMA, DEMA, EMA, KAMA, T3, TEMA, TRIMA, WMA} (ta-lib functions)
        The function for fast moving average (default is pf.SMA).
        MAMA not compatible.
    band : float, {0-100}, optional
        Percent band around the slow moving average.
        (default is 0, which implies no band is used).
    price : str, optional {&#39;close&#39;, &#39;open&#39;, &#39;high&#39;, &#39;low&#39;}
        Input_array column to use for price (default is &#39;close&#39;).
    prevday : bool, optional
        True will shift the series forward.  Unless you are buying
        on the close, you&#39;ll likely want to set this to True.
        It gives you the previous day&#39;s CrossOver (default is False).

    Returns
    -------
    s : pd.Series
        Series that contains the rolling regime indicator values.

    Raises
    ------
    TradeCrossOverError
        If one of the timeperiods specified is invalid.

    Examples
    --------
    &gt;&gt;&gt; ts[&#39;regime&#39;] = pf.CROSSOVER(ts, timeperiod_fast=50,
                                    timeperiod_slow=200)
    &#34;&#34;&#34;
    if (timeperiod_fast &lt; 1 or timeperiod_slow &lt; 2
        or timeperiod_fast &gt;= timeperiod_slow):
        raise TradeCrossOverError

    ts[&#39;__sma_fast__&#39;] = ts[price] if timeperiod_fast == 1 else \
        func_fast(ts, timeperiod=timeperiod_fast, price=price)

    ts[&#39;__sma_slow__&#39;] = \
        func_slow(ts, timeperiod=timeperiod_slow, price=price)

    func = _CrossOver().apply
    s = ts.apply(func, band=band, axis=1)
    if prevday:
        s = s.shift()
    ts.drop([&#39;__sma_fast__&#39;, &#39;__sma_slow__&#39;], axis=1, inplace=True)
    return s


########################################################################
# MOMENTUM

def MOMENTUM(ts, lookback=1, time_frame=&#39;monthly&#39;, price=&#39;close&#39;, prevday=False):
    &#34;&#34;&#34;
    This indicator is used to represent momentum is security prices.

    Percent price change is used to calculate momentum.  Momentum
    is positive if the price since the lookback period has increased.
    Likewise, if price has decreased since the lookback period,
    momentum is negative.  Percent change is used to normalize
    asset prices for comparison.

    Parameters
    ----------
    ts : pd.DateFrame
        A dataframe with &#39;open&#39;, &#39;high&#39;, &#39;low&#39;, &#39;close&#39;, &#39;volume&#39;.
    lookback : int, optional
        The number of time frames to lookback, e.g. 2 months
        (default is 1).
    timeframe : str, optional {&#39;monthly&#39;, &#39;daily&#39;, &#39;weekly&#39;, &#39;yearly&#39;}
        The unit or timeframe type of lookback (default is &#39;monthly&#39;).
    price : str, optional {&#39;close&#39;, &#39;open&#39;, &#39;high&#39;, &#39;low&#39;}
        Input_array column to use for price (default is &#39;close&#39;).
    prevday : bool, optional
        True will shift the series forward.  Unless you are buying
        on the close, you&#39;ll likely want to set this to True.
        It gives you the previous day&#39;s Momentum (default is False).

    Returns
    -------
    s : pd.Series
        Series that contains the rolling momentum indicator values.

    Raises
    ------
    ValueError
        If the lookback is not positive or the time_frame is invalid.

    Examples
    --------
    &gt;&gt;&gt; ts[&#39;mom&#39;] = pf.MOMENTUM(ts, lookback=6, time_frame=&#39;monthly&#39;)
    &#34;&#34;&#34;
    if lookback &lt; 1:
        raise ValueError(&#39;lookback must be positive&#39;)

    if   time_frame ==&#39;daily&#39;:   factor = 1
    elif time_frame ==&#39;weekly&#39;:  factor = pfstatistics.TRADING_DAYS_PER_WEEK
    elif time_frame ==&#39;monthly&#39;: factor = pfstatistics.TRADING_DAYS_PER_MONTH
    elif time_frame ==&#39;yearly&#39;:  factor = pfstatistics.TRADING_DAYS_PER_YEAR
    else:
        raise ValueError(f&#39;invalid time_frame &#34;{time_frame}&#34;&#39;)

    s = ts[price].pct_change(periods=lookback*factor)
    if prevday:
        s = s.shift()

    return s


########################################################################
# VOLATILITY

def VOLATILITY(ts, lookback=20, time_frame=&#39;yearly&#39;, downside=False,
               price=&#39;close&#39;, prevday=False):
    &#34;&#34;&#34;
    This indicator is used to represent volatility in security prices.

    Volatility is represented as the standard deviation.  Volatility
    is calculated over the lookback period, then we scale to the
    time frame.  Volatility scales with the square root of time.
    For example,  if the marketâ€™s daily volatility is 0.5%, then
    volatility for two days is the square root of 2 times
    the daily volatility (0.5% * 1.414 = 0.707%).  We use the square
    root of time to scale from daily to weely, monthly, or yearly.

    Parameters
    ----------
    ts : pd.DateFrame
        A dataframe with &#39;open&#39;, &#39;high&#39;, &#39;low&#39;, &#39;close&#39;, &#39;volume&#39;.
    lookback : int, optional
        The number of time frames to lookback, e.g. 2 months
        (default is 1).
    timeframe : str, optional {&#39;yearly&#39;, &#39;daily&#39;, &#39;weekly&#39;, &#39;monthly&#39;}
        The unit or timeframe used for scaling.  For example, if the
        lookback is 20 and the timeframe is &#39;yearly&#39;, then we compute
        the 20 day volatility and scale to 1 year.
        (default is &#39;yearly&#39;).
    downside : bool, optional
        True to calculate the downside volatility (default is False).
    price : str, optional {&#39;close&#39;, &#39;open&#39;, &#39;high&#39;, &#39;low&#39;}
        Input_array column to use for price (default is &#39;close&#39;).
    prevday : bool, optional
        True will shift the series forward.  Unless you are buying
        on the close, you&#39;ll likely want to set this to True.
        It gives you the previous day&#39;s Volatility (default is False).

    Returns
    -------
    s : pd.Series
        A new column that contains the rolling volatility.

    Raises
    ------
    ValueError
        If the lookback is not positive or the time_frame is invalid.

    Examples
    --------
    &gt;&gt;&gt; ts[&#39;vola&#39;] = pf.VOLATILITY(ts, lookback=20, time_frame=&#39;yearly&#39;)
    &#34;&#34;&#34;
    if lookback &lt; 1:
        raise ValueError(&#39;lookback must be positive&#39;)

    if   time_frame == &#39;daily&#39;:   factor = 1
    elif time_frame == &#39;weekly&#39;:  factor = pfstatistics.TRADING_DAYS_PER_WEEK
    elif time_frame == &#39;monthly&#39;: factor = pfstatistics.TRADING_DAYS_PER_MONTH
    elif time_frame == &#39;yearly&#39;:  factor = pfstatistics.TRADING_DAYS_PER_YEAR
    else:
        raise ValueError(f&#39;invalid time_frame &#34;{time_frame}&#34;&#39;)

    s = ts[price].pct_change()
    if downside:
        s[s &gt; 0] = 0
    s = s.rolling(window=lookback).std() * np.sqrt(factor)

    if prevday:
        s = s.shift()

    return s


########################################################################
# ANNUALIZED_RETURNS

def ANNUALIZED_RETURNS(ts, lookback=5, price=&#39;close&#39;, prevday=False):
    &#34;&#34;&#34;
    Calculate the rolling annualized returns.

    Parameters
    ----------
    ts : pd.DateFrame
        A dataframe with &#39;open&#39;, &#39;high&#39;, &#39;low&#39;, &#39;close&#39;, &#39;volume&#39;.
    lookback : float, optional
        The number of years to lookback, e.g. 5 years.  1/12 can be
        used for 1 month.  Likewise 3/12 for 3 months, etc...
        (default is 5).
    price : str, optional {&#39;close&#39;, &#39;open&#39;, &#39;high&#39;, &#39;low&#39;}
        Input_array column to use for price (default is &#39;close&#39;).
    prevday : bool, optional
        True will shift the series forward.  Unless you are buying
        on the close, you&#39;ll likely want to set this to True.
        It gives you the previous day&#39;s Volatility (default is False).

    Returns
    -------
    s : pd.Series
        Series that contains the rolling annualized returns.

    Raises
    ------
    ValueError
        If the lookback is not positive.

    Examples
    --------
    &gt;&gt;&gt; annual_returns_1mo = pf.ANNUALIZED_RETURNS(ts, lookback=1/12)
    &gt;&gt;&gt; annual_returns_3mo = pf.ANNUALIZED_RETURNS(ts, lookback=3/12)
    &gt;&gt;&gt; annual_returns_1yr = pf.ANNUALIZED_RETURNS(ts, lookback=1)
    &gt;&gt;&gt; annual_returns_3yr = pf.ANNUALIZED_RETURNS(ts, lookback=3)
    &gt;&gt;&gt; annual_returns_5yr = pf.ANNUALIZED_RETURNS(ts, lookback=5)
    &#34;&#34;&#34;
    def _cagr(s):
        &#34;&#34;&#34;
        Calculate compound annual growth rate.

        B = end balance; A = begin balance; n = num years
        &#34;&#34;&#34;
        A = s[0]
        B = s[-1]
        n = len(s)
        if B &lt; 0: B = 0
        return (math.pow(B / A, 1 / n) - 1) * 100

    if lookback &lt;= 0:
        raise ValueError(&#39;lookback must be positive&#39;)

    window = int(lookback * pfstatistics.TRADING_DAYS_PER_YEAR)
    s = pd.Series(ts[price]).rolling(window).apply(_cagr)
    if prevday:
        s = s.shift()

    return s


########################################################################
# ANNUALIZED_STANDARD_DEVIATION

def ANNUALIZED_STANDARD_DEVIATION(ts, lookback=3, price=&#39;close&#39;, prevday=False):
    &#34;&#34;&#34;
    Calculate the rolling annualized standard deviation.

    Parameters
    ----------
    ts : pd.DateFrame
        A dataframe with &#39;open&#39;, &#39;high&#39;, &#39;low&#39;, &#39;close&#39;, &#39;volume&#39;.
    lookback : float, optional
        The number of years to lookback, e.g. 5 years.  1/12 can be
        used for 1 month.  Likewise 3/12 for 3 months, etc...
        (default is 5).
    price : str, optional {&#39;close&#39;, &#39;open&#39;, &#39;high&#39;, &#39;low&#39;}
        Input_array column to use for price (default is &#39;close&#39;).
    prevday : bool, optional
        True will shift the series forward.  Unless you are buying
        on the close, you&#39;ll likely want to set this to True.
        It gives you the previous day&#39;s Volatility (default is False).

    Returns
    -------
    s : pd.Series
        Series that contains the rolling annualized standard deviation.

    Raises
    ------
    ValueError
        If the lookback is not positive.

    Examples
    --------
    &gt;&gt;&gt; std_dev_1mo = pf.ANNUALIZED_STANDARD_DEVIATION(ts,lookback=1/12)
    &gt;&gt;&gt; std_dev_3mo = pf.ANNUALIZED_STANDARD_DEVIATION(ts, lookback=3/12)
    &gt;&gt;&gt; std_dev_1yr = pf.ANNUALIZED_STANDARD_DEVIATION(ts, lookback=1)
    &gt;&gt;&gt; std_dev_3yr = pf.ANNUALIZED_STANDARD_DEVIATION(ts, lookback=3)
    &gt;&gt;&gt; std_dev_5yr = pf.ANNUALIZED_STANDARD_DEVIATION(ts, lookback=5)
    &#34;&#34;&#34;
    def _std_dev(s):
        &#34;&#34;&#34;
        Calculate the annualized standard deviation.
        &#34;&#34;&#34;
        return np.std(s, axis=0) * math.sqrt(pfstatistics.TRADING_DAYS_PER_YEAR)

    if lookback &lt;= 0:
        raise ValueError(&#39;lookback must be positive&#39;)

    window = int(lookback * pfstatistics.TRADING_DAYS_PER_YEAR)
    pc = ts[price].pct_change()
    s = pd.Series(pc).rolling(window).apply(_std_dev)
    if prevday:
        s = s.shift()

    return s


########################################################################
# ANNUALIZED_SHARPE_RATIO

def ANNUALIZED_SHARPE_RATIO(ts, lookback=5, price=&#39;close&#39;, prevday=False,
                            risk_free=0):
    &#34;&#34;&#34;
    Calculate the rolling annualized sharpe ratio.

    Parameters
    ----------
    ts : pd.DateFrame
        A dataframe with &#39;open&#39;, &#39;high&#39;, &#39;low&#39;, &#39;close&#39;, &#39;volume&#39;.
    lookback : float, optional
        The number of years to lookback, e.g. 5 years.  1/12 can be
        used for 1 month.  Likewise 3/12 for 3 months, etc...
        (default is 5).
    price : str, optional {&#39;close&#39;, &#39;open&#39;, &#39;high&#39;, &#39;low&#39;}
        Input_array column to use for price (default is &#39;close&#39;).
    prevday : bool, optional
        True will shift the series forward.  Unless you are buying
        on the close, you&#39;ll likely want to set this to True.
        It gives you the previous day&#39;s Volatility (default is False).
    risk_free: float, optional
        The risk free rate (default is 0).

    Returns
    -------
    s : pd.Series
        Series that contains the rolling annualized sharpe ratio.

    Raises
    ------
    ValueError
        If the lookback is not positive.

    Examples
    --------
    &gt;&gt;&gt; sharpe_ratio_1mo = pf.ANNUALIZED_SHARPE_RATIO(ts, lookback=1/12)
    &gt;&gt;&gt; sharpe_ratio_3mo = pf.ANNUALIZED_SHARPE_RATIO(ts, lookback=3/12)
    &gt;&gt;&gt; sharpe_ratio_1yr = pf.ANNUALIZED_SHARPE_RATIO(ts, lookback=1)
    &gt;&gt;&gt; sharpe_ratio_3yr = pf.ANNUALIZED_SHARPE_RATIO(ts, lookback=3)
    &gt;&gt;&gt; sharpe_ratio_5yr = pf.ANNUALIZED_SHARPE_RATIO(ts, lookback=5)
    &#34;&#34;&#34;
    def _sharpe_ratio(s):
        &#34;&#34;&#34;
        Calculate the annualized sharpe ratio.
        &#34;&#34;&#34;
        dev = np.std(s, axis=0)
        mean = np.mean(s, axis=0)
        period = len(s)
        sharpe = (mean*period - risk_free) / (dev * np.sqrt(period))
        return sharpe

    if lookback &lt;= 0:
        raise ValueError(&#39;lookback must be positive&#39;)

    window = int(lookback * pfstatistics.TRADING_DAYS_PER_YEAR)
    pc = ts[price].pct_change()
    s = pd.Series(pc).rolling(window).apply(_sharpe_ratio)
    if prevday:
        s = s.shift()

    return s</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="pinkfish.indicator.ANNUALIZED_RETURNS"><code class="name flex">
<span>def <span class="ident">ANNUALIZED_RETURNS</span></span>(<span>ts, lookback=5, price='close', prevday=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Calculate the rolling annualized returns.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>ts</code></strong> :&ensp;<code>pd.DateFrame</code></dt>
<dd>A dataframe with 'open', 'high', 'low', 'close', 'volume'.</dd>
<dt><strong><code>lookback</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>The number of years to lookback, e.g. 5 years.
1/12 can be
used for 1 month.
Likewise 3/12 for 3 months, etc&hellip;
(default is 5).</dd>
<dt><strong><code>price</code></strong> :&ensp;<code>str</code>, optional <code>{'close', 'open', 'high', 'low'}</code></dt>
<dd>Input_array column to use for price (default is 'close').</dd>
<dt><strong><code>prevday</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>True will shift the series forward.
Unless you are buying
on the close, you'll likely want to set this to True.
It gives you the previous day's Volatility (default is False).</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>s</code></strong> :&ensp;<code>pd.Series</code></dt>
<dd>Series that contains the rolling annualized returns.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>ValueError</code></dt>
<dd>If the lookback is not positive.</dd>
</dl>
<h2 id="examples">Examples</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; annual_returns_1mo = pf.ANNUALIZED_RETURNS(ts, lookback=1/12)
&gt;&gt;&gt; annual_returns_3mo = pf.ANNUALIZED_RETURNS(ts, lookback=3/12)
&gt;&gt;&gt; annual_returns_1yr = pf.ANNUALIZED_RETURNS(ts, lookback=1)
&gt;&gt;&gt; annual_returns_3yr = pf.ANNUALIZED_RETURNS(ts, lookback=3)
&gt;&gt;&gt; annual_returns_5yr = pf.ANNUALIZED_RETURNS(ts, lookback=5)
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def ANNUALIZED_RETURNS(ts, lookback=5, price=&#39;close&#39;, prevday=False):
    &#34;&#34;&#34;
    Calculate the rolling annualized returns.

    Parameters
    ----------
    ts : pd.DateFrame
        A dataframe with &#39;open&#39;, &#39;high&#39;, &#39;low&#39;, &#39;close&#39;, &#39;volume&#39;.
    lookback : float, optional
        The number of years to lookback, e.g. 5 years.  1/12 can be
        used for 1 month.  Likewise 3/12 for 3 months, etc...
        (default is 5).
    price : str, optional {&#39;close&#39;, &#39;open&#39;, &#39;high&#39;, &#39;low&#39;}
        Input_array column to use for price (default is &#39;close&#39;).
    prevday : bool, optional
        True will shift the series forward.  Unless you are buying
        on the close, you&#39;ll likely want to set this to True.
        It gives you the previous day&#39;s Volatility (default is False).

    Returns
    -------
    s : pd.Series
        Series that contains the rolling annualized returns.

    Raises
    ------
    ValueError
        If the lookback is not positive.

    Examples
    --------
    &gt;&gt;&gt; annual_returns_1mo = pf.ANNUALIZED_RETURNS(ts, lookback=1/12)
    &gt;&gt;&gt; annual_returns_3mo = pf.ANNUALIZED_RETURNS(ts, lookback=3/12)
    &gt;&gt;&gt; annual_returns_1yr = pf.ANNUALIZED_RETURNS(ts, lookback=1)
    &gt;&gt;&gt; annual_returns_3yr = pf.ANNUALIZED_RETURNS(ts, lookback=3)
    &gt;&gt;&gt; annual_returns_5yr = pf.ANNUALIZED_RETURNS(ts, lookback=5)
    &#34;&#34;&#34;
    def _cagr(s):
        &#34;&#34;&#34;
        Calculate compound annual growth rate.

        B = end balance; A = begin balance; n = num years
        &#34;&#34;&#34;
        A = s[0]
        B = s[-1]
        n = len(s)
        if B &lt; 0: B = 0
        return (math.pow(B / A, 1 / n) - 1) * 100

    if lookback &lt;= 0:
        raise ValueError(&#39;lookback must be positive&#39;)

    window = int(lookback * pfstatistics.TRADING_DAYS_PER_YEAR)
    s = pd.Series(ts[price]).rolling(window).apply(_cagr)
    if prevday:
        s = s.shift()

    return s</code></pre>
</details>
</dd>
<dt id="pinkfish.indicator.ANNUALIZED_SHARPE_RATIO"><code class="name flex">
<span>def <span class="ident">ANNUALIZED_SHARPE_RATIO</span></span>(<span>ts, lookback=5, price='close', prevday=False, risk_free=0)</span>
</code></dt>
<dd>
<div class="desc"><p>Calculate the rolling annualized sharpe ratio.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>ts</code></strong> :&ensp;<code>pd.DateFrame</code></dt>
<dd>A dataframe with 'open', 'high', 'low', 'close', 'volume'.</dd>
<dt><strong><code>lookback</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>The number of years to lookback, e.g. 5 years.
1/12 can be
used for 1 month.
Likewise 3/12 for 3 months, etc&hellip;
(default is 5).</dd>
<dt><strong><code>price</code></strong> :&ensp;<code>str</code>, optional <code>{'close', 'open', 'high', 'low'}</code></dt>
<dd>Input_array column to use for price (default is 'close').</dd>
<dt><strong><code>prevday</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>True will shift the series forward.
Unless you are buying
on the close, you'll likely want to set this to True.
It gives you the previous day's Volatility (default is False).</dd>
<dt><strong><code>risk_free</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>The risk free rate (default is 0).</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>s</code></strong> :&ensp;<code>pd.Series</code></dt>
<dd>Series that contains the rolling annualized sharpe ratio.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>ValueError</code></dt>
<dd>If the lookback is not positive.</dd>
</dl>
<h2 id="examples">Examples</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; sharpe_ratio_1mo = pf.ANNUALIZED_SHARPE_RATIO(ts, lookback=1/12)
&gt;&gt;&gt; sharpe_ratio_3mo = pf.ANNUALIZED_SHARPE_RATIO(ts, lookback=3/12)
&gt;&gt;&gt; sharpe_ratio_1yr = pf.ANNUALIZED_SHARPE_RATIO(ts, lookback=1)
&gt;&gt;&gt; sharpe_ratio_3yr = pf.ANNUALIZED_SHARPE_RATIO(ts, lookback=3)
&gt;&gt;&gt; sharpe_ratio_5yr = pf.ANNUALIZED_SHARPE_RATIO(ts, lookback=5)
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def ANNUALIZED_SHARPE_RATIO(ts, lookback=5, price=&#39;close&#39;, prevday=False,
                            risk_free=0):
    &#34;&#34;&#34;
    Calculate the rolling annualized sharpe ratio.

    Parameters
    ----------
    ts : pd.DateFrame
        A dataframe with &#39;open&#39;, &#39;high&#39;, &#39;low&#39;, &#39;close&#39;, &#39;volume&#39;.
    lookback : float, optional
        The number of years to lookback, e.g. 5 years.  1/12 can be
        used for 1 month.  Likewise 3/12 for 3 months, etc...
        (default is 5).
    price : str, optional {&#39;close&#39;, &#39;open&#39;, &#39;high&#39;, &#39;low&#39;}
        Input_array column to use for price (default is &#39;close&#39;).
    prevday : bool, optional
        True will shift the series forward.  Unless you are buying
        on the close, you&#39;ll likely want to set this to True.
        It gives you the previous day&#39;s Volatility (default is False).
    risk_free: float, optional
        The risk free rate (default is 0).

    Returns
    -------
    s : pd.Series
        Series that contains the rolling annualized sharpe ratio.

    Raises
    ------
    ValueError
        If the lookback is not positive.

    Examples
    --------
    &gt;&gt;&gt; sharpe_ratio_1mo = pf.ANNUALIZED_SHARPE_RATIO(ts, lookback=1/12)
    &gt;&gt;&gt; sharpe_ratio_3mo = pf.ANNUALIZED_SHARPE_RATIO(ts, lookback=3/12)
    &gt;&gt;&gt; sharpe_ratio_1yr = pf.ANNUALIZED_SHARPE_RATIO(ts, lookback=1)
    &gt;&gt;&gt; sharpe_ratio_3yr = pf.ANNUALIZED_SHARPE_RATIO(ts, lookback=3)
    &gt;&gt;&gt; sharpe_ratio_5yr = pf.ANNUALIZED_SHARPE_RATIO(ts, lookback=5)
    &#34;&#34;&#34;
    def _sharpe_ratio(s):
        &#34;&#34;&#34;
        Calculate the annualized sharpe ratio.
        &#34;&#34;&#34;
        dev = np.std(s, axis=0)
        mean = np.mean(s, axis=0)
        period = len(s)
        sharpe = (mean*period - risk_free) / (dev * np.sqrt(period))
        return sharpe

    if lookback &lt;= 0:
        raise ValueError(&#39;lookback must be positive&#39;)

    window = int(lookback * pfstatistics.TRADING_DAYS_PER_YEAR)
    pc = ts[price].pct_change()
    s = pd.Series(pc).rolling(window).apply(_sharpe_ratio)
    if prevday:
        s = s.shift()

    return s</code></pre>
</details>
</dd>
<dt id="pinkfish.indicator.ANNUALIZED_STANDARD_DEVIATION"><code class="name flex">
<span>def <span class="ident">ANNUALIZED_STANDARD_DEVIATION</span></span>(<span>ts, lookback=3, price='close', prevday=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Calculate the rolling annualized standard deviation.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>ts</code></strong> :&ensp;<code>pd.DateFrame</code></dt>
<dd>A dataframe with 'open', 'high', 'low', 'close', 'volume'.</dd>
<dt><strong><code>lookback</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>The number of years to lookback, e.g. 5 years.
1/12 can be
used for 1 month.
Likewise 3/12 for 3 months, etc&hellip;
(default is 5).</dd>
<dt><strong><code>price</code></strong> :&ensp;<code>str</code>, optional <code>{'close', 'open', 'high', 'low'}</code></dt>
<dd>Input_array column to use for price (default is 'close').</dd>
<dt><strong><code>prevday</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>True will shift the series forward.
Unless you are buying
on the close, you'll likely want to set this to True.
It gives you the previous day's Volatility (default is False).</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>s</code></strong> :&ensp;<code>pd.Series</code></dt>
<dd>Series that contains the rolling annualized standard deviation.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>ValueError</code></dt>
<dd>If the lookback is not positive.</dd>
</dl>
<h2 id="examples">Examples</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; std_dev_1mo = pf.ANNUALIZED_STANDARD_DEVIATION(ts,lookback=1/12)
&gt;&gt;&gt; std_dev_3mo = pf.ANNUALIZED_STANDARD_DEVIATION(ts, lookback=3/12)
&gt;&gt;&gt; std_dev_1yr = pf.ANNUALIZED_STANDARD_DEVIATION(ts, lookback=1)
&gt;&gt;&gt; std_dev_3yr = pf.ANNUALIZED_STANDARD_DEVIATION(ts, lookback=3)
&gt;&gt;&gt; std_dev_5yr = pf.ANNUALIZED_STANDARD_DEVIATION(ts, lookback=5)
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def ANNUALIZED_STANDARD_DEVIATION(ts, lookback=3, price=&#39;close&#39;, prevday=False):
    &#34;&#34;&#34;
    Calculate the rolling annualized standard deviation.

    Parameters
    ----------
    ts : pd.DateFrame
        A dataframe with &#39;open&#39;, &#39;high&#39;, &#39;low&#39;, &#39;close&#39;, &#39;volume&#39;.
    lookback : float, optional
        The number of years to lookback, e.g. 5 years.  1/12 can be
        used for 1 month.  Likewise 3/12 for 3 months, etc...
        (default is 5).
    price : str, optional {&#39;close&#39;, &#39;open&#39;, &#39;high&#39;, &#39;low&#39;}
        Input_array column to use for price (default is &#39;close&#39;).
    prevday : bool, optional
        True will shift the series forward.  Unless you are buying
        on the close, you&#39;ll likely want to set this to True.
        It gives you the previous day&#39;s Volatility (default is False).

    Returns
    -------
    s : pd.Series
        Series that contains the rolling annualized standard deviation.

    Raises
    ------
    ValueError
        If the lookback is not positive.

    Examples
    --------
    &gt;&gt;&gt; std_dev_1mo = pf.ANNUALIZED_STANDARD_DEVIATION(ts,lookback=1/12)
    &gt;&gt;&gt; std_dev_3mo = pf.ANNUALIZED_STANDARD_DEVIATION(ts, lookback=3/12)
    &gt;&gt;&gt; std_dev_1yr = pf.ANNUALIZED_STANDARD_DEVIATION(ts, lookback=1)
    &gt;&gt;&gt; std_dev_3yr = pf.ANNUALIZED_STANDARD_DEVIATION(ts, lookback=3)
    &gt;&gt;&gt; std_dev_5yr = pf.ANNUALIZED_STANDARD_DEVIATION(ts, lookback=5)
    &#34;&#34;&#34;
    def _std_dev(s):
        &#34;&#34;&#34;
        Calculate the annualized standard deviation.
        &#34;&#34;&#34;
        return np.std(s, axis=0) * math.sqrt(pfstatistics.TRADING_DAYS_PER_YEAR)

    if lookback &lt;= 0:
        raise ValueError(&#39;lookback must be positive&#39;)

    window = int(lookback * pfstatistics.TRADING_DAYS_PER_YEAR)
    pc = ts[price].pct_change()
    s = pd.Series(pc).rolling(window).apply(_std_dev)
    if prevday:
        s = s.shift()

    return s</code></pre>
</details>
</dd>
<dt id="pinkfish.indicator.CROSSOVER"><code class="name flex">
<span>def <span class="ident">CROSSOVER</span></span>(<span>ts, timeperiod_fast=50, timeperiod_slow=200, func_fast=&lt;function SMA&gt;, func_slow=&lt;function SMA&gt;, band=0, price='close', prevday=False)</span>
</code></dt>
<dd>
<div class="desc"><p>This indicator is used to represent regime direction and duration.</p>
<p>For example, an indicator value of 50 means a bull market that has
persisted for 50 days, whereas -20 means a bear market that has
persisted for 20 days.</p>
<p>More generally, this is a crossover indicator for two moving
averages.
The indicator is positive when the fast moving average
is above the slow moving arverage, and negative when the fast
moving average is below the slow moving average.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>ts</code></strong> :&ensp;<code>pd.DateFrame</code></dt>
<dd>A dataframe with 'open', 'high', 'low', 'close', 'volume'.</dd>
<dt><strong><code>timeperiod_fast</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>The timeperiod for the fast moving average (default is 50).</dd>
<dt><strong><code>timeperiod_slow</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>The timeperiod for the slow moving average (default is 200).</dd>
<dt><strong><code>func_fast</code></strong> :&ensp;<code>Function</code>, optional</dt>
<dd>{pf.SMA, pf.EMA} (pinkfish functions) or
{SMA, DEMA, EMA, KAMA, T3, TEMA, TRIMA, WMA} (ta-lib functions)
The function for fast moving average (default is pf.SMA).
MAMA not compatible.</dd>
<dt><strong><code>func_slow</code></strong> :&ensp;<code>Function</code>, optional</dt>
<dd>{pf.SMA, pf.EMA} (pinkfish functions) or
{SMA, DEMA, EMA, KAMA, T3, TEMA, TRIMA, WMA} (ta-lib functions)
The function for fast moving average (default is pf.SMA).
MAMA not compatible.</dd>
<dt><strong><code>band</code></strong> :&ensp;<code>float, {0-100}</code>, optional</dt>
<dd>Percent band around the slow moving average.
(default is 0, which implies no band is used).</dd>
<dt><strong><code>price</code></strong> :&ensp;<code>str</code>, optional <code>{'close', 'open', 'high', 'low'}</code></dt>
<dd>Input_array column to use for price (default is 'close').</dd>
<dt><strong><code>prevday</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>True will shift the series forward.
Unless you are buying
on the close, you'll likely want to set this to True.
It gives you the previous day's CrossOver (default is False).</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>s</code></strong> :&ensp;<code>pd.Series</code></dt>
<dd>Series that contains the rolling regime indicator values.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a title="pinkfish.indicator.TradeCrossOverError" href="#pinkfish.indicator.TradeCrossOverError">TradeCrossOverError</a></code></dt>
<dd>If one of the timeperiods specified is invalid.</dd>
</dl>
<h2 id="examples">Examples</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; ts['regime'] = pf.CROSSOVER(ts, timeperiod_fast=50,
                                timeperiod_slow=200)
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def CROSSOVER(ts, timeperiod_fast=50, timeperiod_slow=200,
              func_fast=SMA, func_slow=SMA, band=0,
              price=&#39;close&#39;, prevday=False):
    &#34;&#34;&#34;
    This indicator is used to represent regime direction and duration.

    For example, an indicator value of 50 means a bull market that has
    persisted for 50 days, whereas -20 means a bear market that has
    persisted for 20 days.

    More generally, this is a crossover indicator for two moving
    averages.  The indicator is positive when the fast moving average
    is above the slow moving arverage, and negative when the fast
    moving average is below the slow moving average.

    Parameters
    ----------
    ts : pd.DateFrame
        A dataframe with &#39;open&#39;, &#39;high&#39;, &#39;low&#39;, &#39;close&#39;, &#39;volume&#39;.
    timeperiod_fast : int, optional
        The timeperiod for the fast moving average (default is 50).
    timeperiod_slow : int, optional
        The timeperiod for the slow moving average (default is 200).
    func_fast : Function, optional
        {pf.SMA, pf.EMA} (pinkfish functions) or
        {SMA, DEMA, EMA, KAMA, T3, TEMA, TRIMA, WMA} (ta-lib functions)
        The function for fast moving average (default is pf.SMA).
        MAMA not compatible.
    func_slow : Function, optional
         {pf.SMA, pf.EMA} (pinkfish functions) or
        {SMA, DEMA, EMA, KAMA, T3, TEMA, TRIMA, WMA} (ta-lib functions)
        The function for fast moving average (default is pf.SMA).
        MAMA not compatible.
    band : float, {0-100}, optional
        Percent band around the slow moving average.
        (default is 0, which implies no band is used).
    price : str, optional {&#39;close&#39;, &#39;open&#39;, &#39;high&#39;, &#39;low&#39;}
        Input_array column to use for price (default is &#39;close&#39;).
    prevday : bool, optional
        True will shift the series forward.  Unless you are buying
        on the close, you&#39;ll likely want to set this to True.
        It gives you the previous day&#39;s CrossOver (default is False).

    Returns
    -------
    s : pd.Series
        Series that contains the rolling regime indicator values.

    Raises
    ------
    TradeCrossOverError
        If one of the timeperiods specified is invalid.

    Examples
    --------
    &gt;&gt;&gt; ts[&#39;regime&#39;] = pf.CROSSOVER(ts, timeperiod_fast=50,
                                    timeperiod_slow=200)
    &#34;&#34;&#34;
    if (timeperiod_fast &lt; 1 or timeperiod_slow &lt; 2
        or timeperiod_fast &gt;= timeperiod_slow):
        raise TradeCrossOverError

    ts[&#39;__sma_fast__&#39;] = ts[price] if timeperiod_fast == 1 else \
        func_fast(ts, timeperiod=timeperiod_fast, price=price)

    ts[&#39;__sma_slow__&#39;] = \
        func_slow(ts, timeperiod=timeperiod_slow, price=price)

    func = _CrossOver().apply
    s = ts.apply(func, band=band, axis=1)
    if prevday:
        s = s.shift()
    ts.drop([&#39;__sma_fast__&#39;, &#39;__sma_slow__&#39;], axis=1, inplace=True)
    return s</code></pre>
</details>
</dd>
<dt id="pinkfish.indicator.EMA"><code class="name flex">
<span>def <span class="ident">EMA</span></span>(<span>ts, timeperiod=30, price='close')</span>
</code></dt>
<dd>
<div class="desc"><p>This indicator computes an exponential moving average.</p>
<p>Can be used in place of talib EMA.</p>
<p>ts : pd.DateFrame or pd.Series
A dataframe with 'open', 'high', 'low', 'close', 'volume' or
a series of price data.
timeperiod: int, optional
The timeperiod for the moving average (default is 30).
price : str, optional {'close', 'open', 'high', 'low'}
Input_array column to use for price (default is 'close').
Not used if <code>ts</code> is a series.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>pd.Series</code></dt>
<dd>Series that contains the simple moving average.</dd>
</dl>
<h2 id="examples">Examples</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; ts['ema50'] = pf.EMA(ts, timeperiod=50)
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def EMA(ts, timeperiod=30, price=&#39;close&#39;):
    &#34;&#34;&#34;
    This indicator computes an exponential moving average.

    Can be used in place of talib EMA.

    ts : pd.DateFrame or pd.Series
        A dataframe with &#39;open&#39;, &#39;high&#39;, &#39;low&#39;, &#39;close&#39;, &#39;volume&#39; or
        a series of price data.
    timeperiod: int, optional
        The timeperiod for the moving average (default is 30).
    price : str, optional {&#39;close&#39;, &#39;open&#39;, &#39;high&#39;, &#39;low&#39;}
        Input_array column to use for price (default is &#39;close&#39;).
        Not used if `ts` is a series.

    Returns
    -------
    pd.Series
        Series that contains the simple moving average.

    Examples
    --------
    &gt;&gt;&gt; ts[&#39;ema50&#39;] = pf.EMA(ts, timeperiod=50)
    &#34;&#34;&#34;
    s = ts[price] if isinstance(ts, pd.DataFrame) else ts
    return s.ewm(span=timeperiod, min_periods=timeperiod, adjust=False).mean()</code></pre>
</details>
</dd>
<dt id="pinkfish.indicator.MOMENTUM"><code class="name flex">
<span>def <span class="ident">MOMENTUM</span></span>(<span>ts, lookback=1, time_frame='monthly', price='close', prevday=False)</span>
</code></dt>
<dd>
<div class="desc"><p>This indicator is used to represent momentum is security prices.</p>
<p>Percent price change is used to calculate momentum.
Momentum
is positive if the price since the lookback period has increased.
Likewise, if price has decreased since the lookback period,
momentum is negative.
Percent change is used to normalize
asset prices for comparison.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>ts</code></strong> :&ensp;<code>pd.DateFrame</code></dt>
<dd>A dataframe with 'open', 'high', 'low', 'close', 'volume'.</dd>
<dt><strong><code>lookback</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>The number of time frames to lookback, e.g. 2 months
(default is 1).</dd>
<dt><strong><code>timeframe</code></strong> :&ensp;<code>str</code>, optional <code>{'monthly', 'daily', 'weekly', 'yearly'}</code></dt>
<dd>The unit or timeframe type of lookback (default is 'monthly').</dd>
<dt><strong><code>price</code></strong> :&ensp;<code>str</code>, optional <code>{'close', 'open', 'high', 'low'}</code></dt>
<dd>Input_array column to use for price (default is 'close').</dd>
<dt><strong><code>prevday</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>True will shift the series forward.
Unless you are buying
on the close, you'll likely want to set this to True.
It gives you the previous day's Momentum (default is False).</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>s</code></strong> :&ensp;<code>pd.Series</code></dt>
<dd>Series that contains the rolling momentum indicator values.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>ValueError</code></dt>
<dd>If the lookback is not positive or the time_frame is invalid.</dd>
</dl>
<h2 id="examples">Examples</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; ts['mom'] = pf.MOMENTUM(ts, lookback=6, time_frame='monthly')
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def MOMENTUM(ts, lookback=1, time_frame=&#39;monthly&#39;, price=&#39;close&#39;, prevday=False):
    &#34;&#34;&#34;
    This indicator is used to represent momentum is security prices.

    Percent price change is used to calculate momentum.  Momentum
    is positive if the price since the lookback period has increased.
    Likewise, if price has decreased since the lookback period,
    momentum is negative.  Percent change is used to normalize
    asset prices for comparison.

    Parameters
    ----------
    ts : pd.DateFrame
        A dataframe with &#39;open&#39;, &#39;high&#39;, &#39;low&#39;, &#39;close&#39;, &#39;volume&#39;.
    lookback : int, optional
        The number of time frames to lookback, e.g. 2 months
        (default is 1).
    timeframe : str, optional {&#39;monthly&#39;, &#39;daily&#39;, &#39;weekly&#39;, &#39;yearly&#39;}
        The unit or timeframe type of lookback (default is &#39;monthly&#39;).
    price : str, optional {&#39;close&#39;, &#39;open&#39;, &#39;high&#39;, &#39;low&#39;}
        Input_array column to use for price (default is &#39;close&#39;).
    prevday : bool, optional
        True will shift the series forward.  Unless you are buying
        on the close, you&#39;ll likely want to set this to True.
        It gives you the previous day&#39;s Momentum (default is False).

    Returns
    -------
    s : pd.Series
        Series that contains the rolling momentum indicator values.

    Raises
    ------
    ValueError
        If the lookback is not positive or the time_frame is invalid.

    Examples
    --------
    &gt;&gt;&gt; ts[&#39;mom&#39;] = pf.MOMENTUM(ts, lookback=6, time_frame=&#39;monthly&#39;)
    &#34;&#34;&#34;
    if lookback &lt; 1:
        raise ValueError(&#39;lookback must be positive&#39;)

    if   time_frame ==&#39;daily&#39;:   factor = 1
    elif time_frame ==&#39;weekly&#39;:  factor = pfstatistics.TRADING_DAYS_PER_WEEK
    elif time_frame ==&#39;monthly&#39;: factor = pfstatistics.TRADING_DAYS_PER_MONTH
    elif time_frame ==&#39;yearly&#39;:  factor = pfstatistics.TRADING_DAYS_PER_YEAR
    else:
        raise ValueError(f&#39;invalid time_frame &#34;{time_frame}&#34;&#39;)

    s = ts[price].pct_change(periods=lookback*factor)
    if prevday:
        s = s.shift()

    return s</code></pre>
</details>
</dd>
<dt id="pinkfish.indicator.SMA"><code class="name flex">
<span>def <span class="ident">SMA</span></span>(<span>ts, timeperiod=30, price='close')</span>
</code></dt>
<dd>
<div class="desc"><p>This indicator computes a simple moving average.</p>
<p>Can be used in place of talib SMA.</p>
<p>ts : pd.DateFrame or pd.Series
A dataframe with 'open', 'high', 'low', 'close', 'volume' or
a series of price data.
timeperiod: int, optional
The timeperiod for the moving average (default is 30).
price : str, optional {'close', 'open', 'high', 'low'}
Input_array column to use for price (default is 'close').
Not used if <code>ts</code> is a series.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>pd.Series</code></dt>
<dd>Series that contains the simple moving average.</dd>
</dl>
<h2 id="examples">Examples</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; ts['sma50'] = pf.SMA(ts, timeperiod=50)
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def SMA(ts, timeperiod=30, price=&#39;close&#39;):
    &#34;&#34;&#34;
    This indicator computes a simple moving average.

    Can be used in place of talib SMA.

    ts : pd.DateFrame or pd.Series
        A dataframe with &#39;open&#39;, &#39;high&#39;, &#39;low&#39;, &#39;close&#39;, &#39;volume&#39; or
        a series of price data.
    timeperiod: int, optional
        The timeperiod for the moving average (default is 30).
    price : str, optional {&#39;close&#39;, &#39;open&#39;, &#39;high&#39;, &#39;low&#39;}
        Input_array column to use for price (default is &#39;close&#39;).
        Not used if `ts` is a series.

    Returns
    -------
    pd.Series
        Series that contains the simple moving average.

    Examples
    --------
    &gt;&gt;&gt; ts[&#39;sma50&#39;] = pf.SMA(ts, timeperiod=50)
    &#34;&#34;&#34;
    s = ts[price] if isinstance(ts, pd.DataFrame) else ts
    return s.rolling(timeperiod).mean()</code></pre>
</details>
</dd>
<dt id="pinkfish.indicator.VOLATILITY"><code class="name flex">
<span>def <span class="ident">VOLATILITY</span></span>(<span>ts, lookback=20, time_frame='yearly', downside=False, price='close', prevday=False)</span>
</code></dt>
<dd>
<div class="desc"><p>This indicator is used to represent volatility in security prices.</p>
<p>Volatility is represented as the standard deviation.
Volatility
is calculated over the lookback period, then we scale to the
time frame.
Volatility scales with the square root of time.
For example,
if the marketâ€™s daily volatility is 0.5%, then
volatility for two days is the square root of 2 times
the daily volatility (0.5% * 1.414 = 0.707%).
We use the square
root of time to scale from daily to weely, monthly, or yearly.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>ts</code></strong> :&ensp;<code>pd.DateFrame</code></dt>
<dd>A dataframe with 'open', 'high', 'low', 'close', 'volume'.</dd>
<dt><strong><code>lookback</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>The number of time frames to lookback, e.g. 2 months
(default is 1).</dd>
<dt><strong><code>timeframe</code></strong> :&ensp;<code>str</code>, optional <code>{'yearly', 'daily', 'weekly', 'monthly'}</code></dt>
<dd>The unit or timeframe used for scaling.
For example, if the
lookback is 20 and the timeframe is 'yearly', then we compute
the 20 day volatility and scale to 1 year.
(default is 'yearly').</dd>
<dt><strong><code>downside</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>True to calculate the downside volatility (default is False).</dd>
<dt><strong><code>price</code></strong> :&ensp;<code>str</code>, optional <code>{'close', 'open', 'high', 'low'}</code></dt>
<dd>Input_array column to use for price (default is 'close').</dd>
<dt><strong><code>prevday</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>True will shift the series forward.
Unless you are buying
on the close, you'll likely want to set this to True.
It gives you the previous day's Volatility (default is False).</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>s</code></strong> :&ensp;<code>pd.Series</code></dt>
<dd>A new column that contains the rolling volatility.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>ValueError</code></dt>
<dd>If the lookback is not positive or the time_frame is invalid.</dd>
</dl>
<h2 id="examples">Examples</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; ts['vola'] = pf.VOLATILITY(ts, lookback=20, time_frame='yearly')
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def VOLATILITY(ts, lookback=20, time_frame=&#39;yearly&#39;, downside=False,
               price=&#39;close&#39;, prevday=False):
    &#34;&#34;&#34;
    This indicator is used to represent volatility in security prices.

    Volatility is represented as the standard deviation.  Volatility
    is calculated over the lookback period, then we scale to the
    time frame.  Volatility scales with the square root of time.
    For example,  if the marketâ€™s daily volatility is 0.5%, then
    volatility for two days is the square root of 2 times
    the daily volatility (0.5% * 1.414 = 0.707%).  We use the square
    root of time to scale from daily to weely, monthly, or yearly.

    Parameters
    ----------
    ts : pd.DateFrame
        A dataframe with &#39;open&#39;, &#39;high&#39;, &#39;low&#39;, &#39;close&#39;, &#39;volume&#39;.
    lookback : int, optional
        The number of time frames to lookback, e.g. 2 months
        (default is 1).
    timeframe : str, optional {&#39;yearly&#39;, &#39;daily&#39;, &#39;weekly&#39;, &#39;monthly&#39;}
        The unit or timeframe used for scaling.  For example, if the
        lookback is 20 and the timeframe is &#39;yearly&#39;, then we compute
        the 20 day volatility and scale to 1 year.
        (default is &#39;yearly&#39;).
    downside : bool, optional
        True to calculate the downside volatility (default is False).
    price : str, optional {&#39;close&#39;, &#39;open&#39;, &#39;high&#39;, &#39;low&#39;}
        Input_array column to use for price (default is &#39;close&#39;).
    prevday : bool, optional
        True will shift the series forward.  Unless you are buying
        on the close, you&#39;ll likely want to set this to True.
        It gives you the previous day&#39;s Volatility (default is False).

    Returns
    -------
    s : pd.Series
        A new column that contains the rolling volatility.

    Raises
    ------
    ValueError
        If the lookback is not positive or the time_frame is invalid.

    Examples
    --------
    &gt;&gt;&gt; ts[&#39;vola&#39;] = pf.VOLATILITY(ts, lookback=20, time_frame=&#39;yearly&#39;)
    &#34;&#34;&#34;
    if lookback &lt; 1:
        raise ValueError(&#39;lookback must be positive&#39;)

    if   time_frame == &#39;daily&#39;:   factor = 1
    elif time_frame == &#39;weekly&#39;:  factor = pfstatistics.TRADING_DAYS_PER_WEEK
    elif time_frame == &#39;monthly&#39;: factor = pfstatistics.TRADING_DAYS_PER_MONTH
    elif time_frame == &#39;yearly&#39;:  factor = pfstatistics.TRADING_DAYS_PER_YEAR
    else:
        raise ValueError(f&#39;invalid time_frame &#34;{time_frame}&#34;&#39;)

    s = ts[price].pct_change()
    if downside:
        s[s &gt; 0] = 0
    s = s.rolling(window=lookback).std() * np.sqrt(factor)

    if prevday:
        s = s.shift()

    return s</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="pinkfish.indicator.IndicatorError"><code class="flex name class">
<span>class <span class="ident">IndicatorError</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Base indicator exception.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class IndicatorError(Exception):
    &#34;&#34;&#34;
    Base indicator exception.
    &#34;&#34;&#34;
    pass</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>builtins.Exception</li>
<li>builtins.BaseException</li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="pinkfish.indicator.TradeCrossOverError" href="#pinkfish.indicator.TradeCrossOverError">TradeCrossOverError</a></li>
</ul>
</dd>
<dt id="pinkfish.indicator.TradeCrossOverError"><code class="flex name class">
<span>class <span class="ident">TradeCrossOverError</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Invalid timeperiod specified.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class TradeCrossOverError(IndicatorError):
    &#34;&#34;&#34;
    Invalid timeperiod specified.
    &#34;&#34;&#34;
    pass</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="pinkfish.indicator.IndicatorError" href="#pinkfish.indicator.IndicatorError">IndicatorError</a></li>
<li>builtins.Exception</li>
<li>builtins.BaseException</li>
</ul>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="pinkfish" href="index.html">pinkfish</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="pinkfish.indicator.ANNUALIZED_RETURNS" href="#pinkfish.indicator.ANNUALIZED_RETURNS">ANNUALIZED_RETURNS</a></code></li>
<li><code><a title="pinkfish.indicator.ANNUALIZED_SHARPE_RATIO" href="#pinkfish.indicator.ANNUALIZED_SHARPE_RATIO">ANNUALIZED_SHARPE_RATIO</a></code></li>
<li><code><a title="pinkfish.indicator.ANNUALIZED_STANDARD_DEVIATION" href="#pinkfish.indicator.ANNUALIZED_STANDARD_DEVIATION">ANNUALIZED_STANDARD_DEVIATION</a></code></li>
<li><code><a title="pinkfish.indicator.CROSSOVER" href="#pinkfish.indicator.CROSSOVER">CROSSOVER</a></code></li>
<li><code><a title="pinkfish.indicator.EMA" href="#pinkfish.indicator.EMA">EMA</a></code></li>
<li><code><a title="pinkfish.indicator.MOMENTUM" href="#pinkfish.indicator.MOMENTUM">MOMENTUM</a></code></li>
<li><code><a title="pinkfish.indicator.SMA" href="#pinkfish.indicator.SMA">SMA</a></code></li>
<li><code><a title="pinkfish.indicator.VOLATILITY" href="#pinkfish.indicator.VOLATILITY">VOLATILITY</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="pinkfish.indicator.IndicatorError" href="#pinkfish.indicator.IndicatorError">IndicatorError</a></code></h4>
</li>
<li>
<h4><code><a title="pinkfish.indicator.TradeCrossOverError" href="#pinkfish.indicator.TradeCrossOverError">TradeCrossOverError</a></code></h4>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>